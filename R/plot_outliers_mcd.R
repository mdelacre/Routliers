#' MCD function to detect outliers
#' @export plot_outliers_mcd
#' @param data matrix of bivariate values from which we want to compute outliers
#' @param h when using the MMCD method, proportion of dataset to used in order to compute sample means and covariances
#' @param alpha alpha value (by default .01)
#' @param na.rm set whether Missing Values should be excluded (na.rm=TRUE) or not (na.rm=FALSE) - defaults to TRUE
#' @param verbose logical variable indicating whether text output should be generated (verbose = TRUE) or not (verbose = FALSE) - default to TRUE
#' @keywords plot MMCD outliers
#' @examples
#' ## Run plot_outliers_mcd
#' Sigma=matrix(c(1,.5,.5,1),2,2)
#' data=mvrnorm(100,mu=rep(0,2),Sigma=Sigma)
#' plot_outliers_mcd(data=data, h=.5,na.rm=TRUE,plot=TRUE, verbose=TRUE)
#' @importFrom stats mahalanobis lm na.omit qchisq
#' @importFrom MASS cov.mcd
#' @importFrom graphics abline legend par points

plot_outliers_mcd=function(data,
                      h=.5, # fraction of data we wanna keep to compute the MCD (between 0 and 1)
                      alpha=.01,
                      na.rm = TRUE,
                      verbose = TRUE){

  if (na.rm==TRUE) {
    dat=na.omit(data)
  } else {dat=data}

  for (i in 1:ncol(dat)){
    if(inherits(dat[,i],c("numeric","integer"))==FALSE) stop("Data are neither numeric nor integer")
  }

  #Creating covariance matrix for Minimum Covariance Determinant
  output<-cov.mcd(dat,cor=FALSE,quantile.used=nrow(dat)*h) # by default, use the "best" method = exhaustive method
  cutoff<-(qchisq(p=1-alpha, df=ncol(dat))) # how to compute df? Read the text and add it (2 si 2 variables, c dc tj ?gal ? k? ? checker)
  # cor = FALSE to avoid useless output(correlation matrix)

  #Distances from centroid for each matrix
  dist<-mahalanobis(dat,output$center,output$cov) # distance
  #Detecting outliers
  names_outliers<-which(dist>cutoff)
  coordinates <- list(x_axis=dat[,1][dist>cutoff],y_axis=dat[,2][dist>cutoff])
  outliers<-cbind(x_axis=coordinates$x_axis,y_axis=coordinates$y_axis)
  if (length(names_outliers)!=0){rownames(outliers)=paste("POS",names_outliers)}

  # plotting results
    par(xpd=FALSE)
    plot(dat[,1],dat[,2],xlab="X",ylab="Y",pch=19,cex=.5)
    center=cov.mcd(dat,cor=FALSE,quantile.used=nrow(dat)*h)$center
    abline(h=center[2],col="lightgrey",lty=2)
    abline(v=center[1],col="lightgrey",lty=2)
    abline(lm(dat[,2]~dat[,1]),col="darkviolet") # regression line, based on ALL values (y=dv, x = predictor)
    if (length(names_outliers)>0){           # if there are outliers, compute the regression line excluding it
      dat2<-dat[-names_outliers,]           # matrix without outliers (IF there are outliers)
      mod<-lm(dat2[,2]~dat2[,1])              # regression line computed without outliers
      abline(mod,col="darkgreen")}
    par(xpd=TRUE,mar=c(2,2,4,2))
    if (length(names_outliers)==0){
      legend(x="top",xjust="centered",inset=c(0,-.2),legend = "Regression line",fill = "darkviolet",box.lty=0)
    } else if (length(names_outliers)==1){
      points(dat[names_outliers,][1],dat[names_outliers,][2],col="red",bg="red",pch=19,cex=.5)
      text(dat[names_outliers,][1],dat[names_outliers,][2], as.character(names_outliers),pos=4,cex=.75,col="red")
      legend(x="top",xjust="centered",inset=c(0,-.2),legend = c("Regression line including all data","Regression line without detected outliers"),fill = c("darkviolet","darkgreen"),box.lty=0)
    } else if (length(names_outliers)>1){
      points(dat[names_outliers,][,1],dat[names_outliers,][,2],col="red",bg="red",pch=19,cex=.5)
      text(dat[names_outliers,][,1],dat[names_outliers,][,2], as.character(names_outliers),pos=4,cex=.75,col="red")
      legend(x="top",xjust="centered",inset=c(0,-.2),legend = c("Regression line including all data","Regression line without detected outliers"),fill = c("darkviolet","darkgreen"),box.lty=0)}

}

